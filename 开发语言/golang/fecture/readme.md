[TOC]
## golang代码特点总结
### 工作空间
- src 源文件, 被组成包   
- pkg 包对象
- bin 可执行文件
- gopath 工作空间位置
- goroot go安装位置
### 格式化
- go fmt(统一标准)
- 缩减(tab), 行长(\ tab 下行), 括号(尽可少)
### 注释
- //   (行)
- /**/ (块注释)
### 命名
- 大小写敏感(文件名类unix, 包名小写尽短, 避免变量方法名过长, 合理注释)
- 获取器(不支持Get, Set方法, 自己实现应用Name(), SetName()更合理)
- 接口名(单方法接口应以-er结尾, eg. Stringer, Reader, Writer, Flusher等)
- 驼峰命名变量等
### 分号
- 编译器自动补全
- 注意一些挂号等结尾
### 流程控制
- if, for, switch (可接收初始化语句)
- select(类型选择和多路通信复用器)
- 相对其他语言的特点(没有圆括号, 有大括号)
- 对应的流程结束语句 break, continue, return, goto(尽量少用)
- 重新声明与再次赋值, 也就是 := 的使用
### 函数
- 可以多个返回值
- 可设置返回值的形参
- defer延时执行(处理一些资源的关闭, 互斥锁等业务, 是一种栈调用, 会求延时函数里面的函数)
### new分配
- 分配内存函数, 不会初始化内存, 只会将内存置零
- 返回指针类型数据
- 当分配的零值不够完美时, 需要一个初始化构造函数, 一般都是用New开头
- new(file) 等价于 &file{}
### make分配
- 只能用来创建slice, map, channel 返回一个已初始化的值类型
- 因为这三个数据是引用类型，使用的时候必须初始化
### 数据&切片
- 切片动态扩容的优化等
### 初始化
- 常量(iota), 变量
- init()源文件初始化
### 方法
- 以指针或值为接收者的区别在于：值方法可通过指针和值调用， 而指针方法只能通过指针来调用
### 接口
- 一组方法的集合, 任何类型都能定义方法
- 空接口的特殊性, 表示任何类型都实现了interface{}
- 该类型实现了接口的方法, 就表示实现了该接口
### 类型转换与断言
- 由编译器自动转换或通过switch...case进行转换
- 类型断言 value.(typeName)
### 未使用的变量和包
- 空白标识符放在导入包前面可以起到只允许init()行为
- 变量也可以用空白标识符处理, 在debug使用防止编译器报错
### 内嵌
- 结构体的内嵌
- 接口的内嵌
### channel
- make为通道分配内存, 分为带缓冲区或不带缓冲区的通道
- 无缓冲区实现了同步的交换数据
- 解决共享变量安全访问的问题
- 信号必须在信道的接收端获取, 而非发送端, 数据的同步在接收端(也就是发送在接收前)
### goroutine
- 轻量级的, 处在同一地址空间, 用户态, 最开始只有4k的栈空间, 只有需要时才有堆的分配与释放
- 实现多路复用, 一个线程阻塞, 不影响其他goroutine
### 并行与并发
- 并发多个程序可以同时运行现象, 只是相互切换的时间短, 看上去同时执行
- 并行是利用多核cpu, 从物理层同时执行两个程序
### panic/recover/defer
- 用户代替错误处理, 意见保留
### 为啥没有泛型
- 主要是编译的复杂性
- 可用interface{}来替代

